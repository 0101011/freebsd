\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{tikz}
\usepackage{url}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{ifthen}
\usepackage{bytefield}

\usetikzlibrary{positioning}
\usetikzlibrary{shapes}
\usetikzlibrary{arrows}
\usetikzlibrary{chains}
\usetikzlibrary{calc}

\input{../course.tex}

\title{Synchronisation in FreeBSD kernel}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}[fragile]
\frametitle{Data consistency problem}
\begin{beamercolorbox}[rounded=true,shadow=true]{source}
\lstset{language=C}
\begin{lstlisting}
elm1->elm_next = elm2;
elm2->elm_next = elm3;
elm3->elm_prev = elm2;
elm2->elm_prev = elm1;
\end{lstlisting}
\end{beamercolorbox}
\begin{figure}
\begin{tikzpicture}[every node/.style={draw, node distance=20mm}]
  \node [name=elm1, struct, rectangle split parts = 3] {
    \textbf{elm1}
    \nodepart{two} *elm\_prev
    \nodepart{three} *elm\_next
  };
  \node [name=elm2, below right=of elm1, struct, rectangle split parts = 3] {
    \textbf{elm2}
    \nodepart{two} *elm\_prev
    \nodepart{three} *elm\_next
  };
  \node [name=elm3, above right=of elm2, struct, rectangle split parts = 3] {
    \textbf{elm3}
    \nodepart{two} *elm\_prev
    \nodepart{three} *elm\_next
  };
  \onslide<1> {
    \draw [->] (elm1.three east) to [out=0,in=180] (elm3.one west);
  }
  \onslide<-3> {
    \draw [->] (elm3.two west) to [out=180,in=0] (elm1.one east);
  }
  \onslide<2-> {
    \draw [->] (elm1.three east) to [out=0,in=180] (elm2.one west);
  }
  \onslide<3-> {
    \draw [->] (elm2.three east) to [out=0,in=180] (elm3.one west);
  }
  \onslide<4-> {
    \draw [->] (elm3.two west) to [out=180,in=0] (elm2.one east);
  }
  \onslide<5-> {
    \draw [->] (elm2.two west) to [out=180,in=0] (elm1.one east);
  }
\end{tikzpicture}
\end{figure}
\end{frame}


\FootReferences{critical(9)}{sys/kern/kern\_switch.c}
\begin{frame}[fragile]
\frametitle{Critical section}
{\Large{Solution for uniprocessor: enter \emph{critical section}, marking current thread as non-preemptable.}}
\begin{beamercolorbox}[rounded=true,shadow=true]{source}
\lstset{language=C}
\begin{lstlisting}
critical_enter();
elm1->elm_next = elm2;
elm2->elm_next = elm3;
elm3->elm_prev = elm2;
elm2->elm_prev = elm1;
critical_exit();
\end{lstlisting}
\end{beamercolorbox}
\end{frame}


\begin{frame}[fragile]
\frametitle{Critical section (implementation)}
\emph{Hard} critical sections disable interrupts.
\emph{Soft} ones advice mark thread as non-preemptable.
\Man{critical}{9} is \emph{soft}.
\begin{beamercolorbox}[rounded=true,shadow=true]{source}
\lstset{language=C}
\begin{lstlisting}
void
critical_enter(void)  
{
        struct thread *td;

        td = curthread;
        td->td_critnest++;
}
\end{lstlisting}
\end{beamercolorbox}
\end{frame}


\begin{frame}
\frametitle{Maintaining data consistency on SMP}
\begin{tabular}{cc}
	{\Large CPU 1, thread A}	& {\Large CPU 2, thread B}\\
\only<1> { & \\ }
\only<2> { tdA->td\_critnest++		& tdB->td\_critnest++ \\ }
\only<1-2> {
	elm1->elm\_next = elm2;		& elm1->elm\_next = elm2;\\
	elm2->elm\_next = elm3;		& elm2->elm\_next = elm3;\\
	elm3->elm\_prev = elm2;		& elm3->elm\_prev = elm2;\\
	elm2->elm\_prev = elm1;		& elm2->elm\_prev = elm1;\\
}
\only<3> {
	lock(elm\_lock);		& lock(elm\_lock);\\
	elm1->elm\_next = elm2;		& \emph{blocked}\\
	elm2->elm\_next = elm3;		& \emph{blocked}\\
	elm3->elm\_prev = elm2;		& \emph{blocked}\\
	elm2->elm\_prev = elm1;		& \emph{blocked}\\
	unlock(elm\_lock);		& elm1->elm\_next = elm2;\\
	\ldots				& elm2->elm\_next = elm3;\\
}
\end{tabular}
\end{frame}


\FootReferences{mutex(9)}{}
\begin{frame}[fragile]
\frametitle{Naive idea of mutual exclusion lock (mutex)}
\begin{beamercolorbox}[rounded=true,shadow=true]{source}
\lstset{language=C}
\begin{lstlisting}
void
lock(lock_t l)  
{
        struct thread *td;

        td = curthread;

spin:
        if (l == NULL)
                l = (lock_t )td;
        else
                goto spin;
}
\end{lstlisting}
\end{beamercolorbox}
\end{frame}


\FootReferences{atomic(9)}{sys/amd64/include/atomic.h}
\begin{frame}[fragile]
\frametitle{Working idea of a minimal mutual exclusion lock (mutex)}
\begin{beamercolorbox}[rounded=true,shadow=true]{source}
\lstset{language=C}
\begin{lstlisting}
void
lock(lock_t l)  
{
        struct thread *td;

        td = curthread;

spin:
        if (atomic_cmpset(&l, NULL, td) == 0)
                goto spin;
}
\end{lstlisting}
\end{beamercolorbox}
\end{frame}


\FootReferences{mutex(9), atomic(9)}{sys/kern/mutex.h}
\begin{frame}[fragile]
\frametitle{mutex(9) implementation}
\begin{verbatim}
struct mtx {
    /* Common lock properties. */
    struct lock_object  lock_object;
    /* Owner and flags. */
    volatile uintptr_t  mtx_lock;
};
\end{verbatim}
mtx\_lock:\\
\begin{bytefield}{32}
\bitheader[endianness=big]{0,1,2,3,10,11} \\
\bitbox{21}{thread pointer} & \bitbox{8}{unused} &
\bitbox{1}{U} & \bitbox{1}{C} & \bitbox{1}{R}
\end{bytefield}
\begin{verbatim}
#define MTX_RECURSED    0x00000001   /* lock recursed */
#define MTX_CONTESTED   0x00000002   /* lock contested */
#define MTX_UNOWNED     0x00000004   /* free mutex */

atomic_cmpset_acq_ptr(&(mp)->mtx_lock, MTX_UNOWNED, (td))
\end{verbatim}
\end{frame}


\FootReferences{mutex(9)}{sys/kern/mutex.h, sys/kern/kern\_mutex.c}
\begin{frame}
\frametitle{mutex(9) implementation}
\begin{figure}
\begin{tikzpicture}[>=triangle 60, start chain=going below,
		    node distance=5mm,
		    every join/.style={->, draw},
		    font=\scriptsize]
\tikzset {
  base/.style={draw, thick, on chain, align=center, minimum height=4ex},
  proc/.style={base, rectangle},
  test/.style={base, diamond, aspect=3},
  term/.style={proc, rounded corners},
}
\node [name=entry, proc] {mtx\_lock()};
\node [name=atomic, test] {atomic\_cmpset(td)};
\node [name=exit, term] {return};
\node [name=ownerruns, test, right=of atomic] {owner running?};
\node [name=trywait, proc] {turnstile\_trywait};
\node [name=ownerruns2, test, join] {owner running?};
\node [name=contested, test] {atomic\_cmpset(C)};
\node [name=wait, proc, left=of contested] {turnstile\_wait};
\node [name=cancel, proc, right=of ownerruns2] {turnstile\_cancel};

\draw [->] (entry.south) to node [name=entry2,midway] {} (atomic);
\draw [->] (atomic.south) to node [xshift=1em, green] {$yes$} (exit); 
\draw [->] (atomic.east) to node [yshift=1em, red] {$no$} (ownerruns); 
\draw [->] (ownerruns.south) to node [xshift=1em, green] {$yes$} (trywait); 
\draw [->] (ownerruns.north) |- node [xshift=1ex, yshift=-1ex, red] {$no$}
	   (entry2.center); 
\draw [->] (ownerruns2.south) to node [xshift=1em, green] {$yes$} (contested); 
\draw [->] (ownerruns2.east) to node [yshift=1em, red] {$no$} (cancel); 
\draw [->] (cancel.north) |- (entry2.center);
\draw [->] (contested.east) -| node [pos=0, yshift=1em, red] {$no$}
	   (cancel.south);
\draw [->] (contested.west) to node [yshift=1em, green] {$yes$} (wait);
\draw [->] (wait) -- (atomic.west |- wait) -- +(-2mm, 0) |- (entry2.center);
\end{tikzpicture}
\end{figure}
\end{frame}

\FootReferences{mutex(9)}{sys/kern/subr\_turnstile.c, sys/kern/kern\_mutex.c}
\begin{frame}
\frametitle{mutex(9) implementation: turnstile}
\begin{figure}
\begin{tikzpicture}[every node/.style={draw, node distance=10mm}]
  \node [name=turnstile, struct, rectangle split parts = ]
    \textbf{struct turnstile}
    \nodepart{two} LIST\_HEAD ts\_blocked
    \nodepart{two} LIST\_HEAD ts\_pending
\end{tikzpicture}
\end{figure}
\end{frame}

\end{document}
