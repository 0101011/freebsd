\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{tikz}
\usepackage{url}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{ifthen}
\usepackage{bytefield}

\usetikzlibrary{positioning}
\usetikzlibrary{shapes}
\usetikzlibrary{arrows}
\usetikzlibrary{chains}
\usetikzlibrary{calc}

\input{../course.tex}

\title{Synchronisation in FreeBSD kernel}

\begin{document}

\begin{frame}
\titlepage
\end{frame}

\begin{frame}[fragile]
\frametitle{Data consistency problem}
\begin{beamercolorbox}[rounded=true,shadow=true]{source}
\lstset{language=C}
\begin{lstlisting}
elm1->elm_next = elm2;
elm2->elm_next = elm3;
elm3->elm_prev = elm2;
elm2->elm_prev = elm1;
\end{lstlisting}
\end{beamercolorbox}
\begin{figure}
\begin{tikzpicture}[every node/.style={draw, node distance=20mm}]
  \node [name=elm1, struct, rectangle split parts = 3] {
    \textbf{elm1}
    \nodepart{two} *elm\_prev
    \nodepart{three} *elm\_next
  };
  \node [name=elm2, below right=of elm1, struct, rectangle split parts = 3] {
    \textbf{elm2}
    \nodepart{two} *elm\_prev
    \nodepart{three} *elm\_next
  };
  \node [name=elm3, above right=of elm2, struct, rectangle split parts = 3] {
    \textbf{elm3}
    \nodepart{two} *elm\_prev
    \nodepart{three} *elm\_next
  };
  \onslide<1> {
    \draw [->] (elm1.three east) to [out=0,in=180] (elm3.one west);
  }
  \onslide<-3> {
    \draw [->] (elm3.two west) to [out=180,in=0] (elm1.one east);
  }
  \onslide<2-> {
    \draw [->] (elm1.three east) to [out=0,in=180] (elm2.one west);
  }
  \onslide<3-> {
    \draw [->] (elm2.three east) to [out=0,in=180] (elm3.one west);
  }
  \onslide<4-> {
    \draw [->] (elm3.two west) to [out=180,in=0] (elm2.one east);
  }
  \onslide<5-> {
    \draw [->] (elm2.two west) to [out=180,in=0] (elm1.one east);
  }
\end{tikzpicture}
\end{figure}
\end{frame}


\FootReferences{critical(9)}{sys/kern/kern\_switch.c}
\begin{frame}[fragile]
\frametitle{Critical section}
{\Large{Solution for uniprocessor: enter \emph{critical section}, marking current thread as non-preemptable.}}
\begin{beamercolorbox}[rounded=true,shadow=true]{source}
\lstset{language=C}
\begin{lstlisting}
critical_enter();
elm1->elm_next = elm2;
elm2->elm_next = elm3;
elm3->elm_prev = elm2;
elm2->elm_prev = elm1;
critical_exit();
\end{lstlisting}
\end{beamercolorbox}
\end{frame}


\begin{frame}[fragile]
\frametitle{Critical section (implementation)}
\emph{Hard} critical sections disable interrupts.
\emph{Soft} ones advice mark thread as non-preemptable.
\Man{critical}{9} is \emph{soft}.
\begin{beamercolorbox}[rounded=true,shadow=true]{source}
\lstset{language=C}
\begin{lstlisting}
void
critical_enter(void)  
{
        struct thread *td;

        td = curthread;
        td->td_critnest++;
}
\end{lstlisting}
\end{beamercolorbox}
\end{frame}


\begin{frame}
\frametitle{Maintaining data consistency on SMP}
\begin{tabular}{cc}
	{\Large CPU 1, thread A}	& {\Large CPU 2, thread B}\\
\only<1> { & \\ }
\only<2> { tdA->td\_critnest++		& tdB->td\_critnest++ \\ }
\only<1-2> {
	elm1->elm\_next = elm2;		& elm1->elm\_next = elm2;\\
	elm2->elm\_next = elm3;		& elm2->elm\_next = elm3;\\
	elm3->elm\_prev = elm2;		& elm3->elm\_prev = elm2;\\
	elm2->elm\_prev = elm1;		& elm2->elm\_prev = elm1;\\
}
\only<3> {
	lock(elm\_lock);		& lock(elm\_lock);\\
	elm1->elm\_next = elm2;		& \emph{blocked}\\
	elm2->elm\_next = elm3;		& \emph{blocked}\\
	elm3->elm\_prev = elm2;		& \emph{blocked}\\
	elm2->elm\_prev = elm1;		& \emph{blocked}\\
	unlock(elm\_lock);		& elm1->elm\_next = elm2;\\
	\ldots				& elm2->elm\_next = elm3;\\
}
\end{tabular}
\end{frame}


\FootReferences{mutex(9)}{}
\begin{frame}[fragile]
\frametitle{Naive idea of mutual exclusion lock (mutex)}
\begin{beamercolorbox}[rounded=true,shadow=true]{source}
\lstset{language=C}
\begin{lstlisting}
void
lock(lock_t l)  
{
        struct thread *td;

        td = curthread;

spin:
        if (l == NULL)
                l = (lock_t )td;
        else
                goto spin;
}
\end{lstlisting}
\end{beamercolorbox}
\end{frame}


\FootReferences{atomic(9)}{sys/amd64/include/atomic.h}
\begin{frame}[fragile]
\frametitle{Working idea of a minimal mutual exclusion lock (mutex)}
\begin{beamercolorbox}[rounded=true,shadow=true]{source}
\lstset{language=C}
\begin{lstlisting}
void
lock(lock_t l)  
{
        struct thread *td;

        td = curthread;

spin:
        if (atomic_cmpset(&l, NULL, td) == 0)
                goto spin;
}
\end{lstlisting}
\end{beamercolorbox}
\end{frame}


\FootReferences{mutex(9), atomic(9)}{sys/kern/mutex.h}
\begin{frame}[fragile]
\frametitle{mutex(9) implementation}
\begin{verbatim}
struct mtx {
    /* Common lock properties. */
    struct lock_object  lock_object;
    /* Owner and flags. */
    volatile uintptr_t  mtx_lock;
};
\end{verbatim}
\begin{bytefield}{32}
\bitheader[endianness=big]{0,1,2,3,10,11} \\
\bitbox{21}{owner(td pointer)} & \bitbox{8}{unused} &
\bitbox{1}{U} & \bitbox{1}{C} & \bitbox{1}{R}
\end{bytefield}
\onslide<2-> {
\begin{tabular}{l l l l}
\#define & MTX\_RECURSED    & 0x00000001   & /* lock recursed */	\\
\#define & MTX\_CONTESTED   & 0x00000002   & /* lock contested */	\\
\#define & MTX\_UNOWNED     & 0x00000004   & /* free mutex */		\\
\end{tabular}
}
\onslide<3-> {
\srcline{atomic\_cmpset\_acq\_ptr(\&(mp)->mtx\_lock, MTX\_UNOWNED, (td))}
}
\end{frame}


\FootReferences{mutex(9)}{sys/kern/mutex.h, sys/kern/kern\_mutex.c}
\begin{frame}
\frametitle{mutex(9) implementation}
\begin{figure}
\begin{tikzpicture}[>=triangle 60, start chain=going below,
		    node distance=5mm,
		    every join/.style={->, draw},
		    font=\scriptsize]
\tikzset {
  base/.style={draw, thick, on chain, align=center, minimum height=4ex},
  proc/.style={base, rectangle},
  test/.style={base, diamond, aspect=3},
  term/.style={proc, rounded corners},
}
\node [name=entry, proc] {mtx\_lock()};
\node [name=atomic, test] {atomic\_cmpset(td)};
\node [name=exit, term] {return};
\node [name=ownerruns, test, right=of atomic] {owner running?};
\node [name=trywait, proc] {turnstile\_trywait};
\node [name=ownerruns2, test, join] {owner running?};
\node [name=contested, test] {atomic\_cmpset(C)};
\node [name=wait, proc, left=of contested] {turnstile\_wait};
\node [name=cancel, proc, right=of ownerruns2] {turnstile\_cancel};

\draw [->] (entry.south) to node [name=entry2,midway] {} (atomic);
\draw [->] (atomic.south) to node [xshift=1em, green] {$yes$} (exit); 
\draw [->] (atomic.east) to node [yshift=1em, red] {$no$} (ownerruns); 
\draw [->] (ownerruns.south) to node [xshift=1em, green] {$yes$} (trywait); 
\draw [->] (ownerruns.north) |- node [xshift=1ex, yshift=-1ex, red] {$no$}
	   (entry2.center); 
\draw [->] (ownerruns2.south) to node [xshift=1em, green] {$yes$} (contested); 
\draw [->] (ownerruns2.east) to node [yshift=1em, red] {$no$} (cancel); 
\draw [->] (cancel.north) |- (entry2.center);
\draw [->] (contested.east) -| node [pos=0, yshift=1em, red] {$no$}
	   (cancel.south);
\draw [->] (contested.west) to node [yshift=1em, green] {$yes$} (wait);
\draw [->] (wait) -- (atomic.west |- wait) -- +(-2mm, 0) |- (entry2.center);
\end{tikzpicture}
\end{figure}
\end{frame}


\FootReferences{mutex(9)}{sys/kern/mutex.h, sys/kern/kern\_mutex.c}
\begin{frame}
\frametitle{mutex(9) implementation}
\begin{figure}
\begin{tikzpicture}[>=triangle 60, start chain=going below,
		    node distance=1cm,
		    every join/.style={->, draw},
		    font=\scriptsize]
\tikzset {
  base/.style={draw, thick, on chain, align=center, minimum height=4ex},
  proc/.style={base, rectangle},
  test/.style={base, diamond, aspect=3},
  term/.style={proc, rounded corners},
}
\node [name=entry, proc] {mtx\_unlock()};
\node [name=atomic, test] {atomic\_cmpset(td)};
\node [name=exit, term] {return};
\node [name=broadcast, proc, right=3.3cm of atomic] {turnstile\_broadcast};

\draw [->] (entry.south) to (atomic);
\draw [->] (atomic.south) to node [xshift=1em, green]
	   {MTX\_CONTESTED is 0} (exit); 
\draw [->] (atomic.east) to node [yshift=1em, red]
	   {MTX\_CONTESTED is 1} (broadcast); 
\draw [->] (broadcast.south) |- (exit);
\end{tikzpicture}
\end{figure}
\end{frame}


\FootReferences{rwlock(9)}{sys/sys/rwlock.h, sys/kern/kern\_rwlock.c}
\begin{frame}[fragile]
\frametitle{rwlock(9)}
\begin{verbatim}
struct rwlock {
    struct lock_object  lock_object;
    volatile uintptr_t  rw_lock;
};
\end{verbatim}
\begin{bytefield}[bitwidth=2em]{12}
\bitheader[endianness=big]{0,1,2,3,4} \\
\bitbox{8}{owner/reader count} &
\bitbox{1}{WS} & \bitbox{1}{WW} & \bitbox{1}{RW} & \bitbox{1}{R}
\end{bytefield}
\onslide<2-> \scriptsize {
\begin{tabular}{l l l}
\#define & RW\_LOCK\_READ		& 0x01 \\
\#define & RW\_LOCK\_READ\_WAITERS	& 0x02 \\
\#define & RW\_LOCK\_WRITE\_WAITERS	& 0x04 \\
\#define & RW\_LOCK\_WRITE\_SPINNER	& 0x08 \\
\#define & RW\_LOCK\_FLAGMASK		& 0x0f \\
\end{tabular}
\begin{tabular}{l l l}
\#define & RW\_OWNER(x)			& ((x) \& ~RW\_LOCK\_FLAGMASK) \\
\#define & RW\_READERS(x)		& (RW\_OWNER((x)) >> RW\_READERS\_SHIFT)
\end{tabular}
}
\end{frame}


\FootReferences{}{sys/kern/subr\_turnstile.c}
\begin{frame}
\frametitle<1,2>{turnstile idea}
\frametitle<3->{priority propagation}
\begin{figure}
\begin{tikzpicture}[node distance=1mm]
  % the turnstile
  \node [name=tcent, circle, minimum width=1mm, draw, fill=black] {};
  \node [name=turnstile, circle, minimum width=27mm, draw, thick] at (tcent){};
  \draw [thick] (node cs:name=turnstile, angle=45)
	-- (node cs:name=turnstile, angle=225);
  \draw [thick] (node cs:name=turnstile, angle=135)
	-- (node cs:name=turnstile, angle=315);
  \draw [thick] (node cs:name=turnstile, angle=135)
	-- node[above, pos=.2] {turnstile} +(-3cm,0);
  \draw [thick] (node cs:name=turnstile, angle=225) -- +(-3cm,0);
\onslide<1,3-> {
  \node [name=tdA, left=of tcent, circle, draw, thick] { tdA };
  \node [name=tdB, left=of tdA, circle, draw, thick] { tdB };
  \node [name=tdC, left=of tdB, circle, draw, thick] { tdC };
  \node [name=dots, left=of tdC, circle] { \ldots };
}
\onslide<2> {
  \node [name=tdA, left=of tcent, circle, draw, thick] { tdB };
  \node [name=tdB, left=of tdA, circle, draw, thick] { tdC };
  \node [name=tdC, left=of tdB, circle] { \ldots };
  \node [name=dots, left=of tdC, circle] { \ldots };
}

  % lock & owner
  \node [name=lock, above=1.5cm of turnstile, draw, thick, rounded corners]
	{\Large{lock}};
  \draw [<->,thick] (lock) -- (turnstile);
\onslide<1,3-> {
  \node [name=owner, right=1.5cm of lock, draw, thick, circle] {tdO};
}
\onslide<2> {
  \node [name=owner, right=1.5cm of lock, draw, thick, circle] {tdA};
  \node [name=old, below right=1cm and 1cm of owner, draw, thick, circle]
	{tdO};
}
  \draw [->, thick] (lock) -- node [above] {owner} (owner);

\onslide<2> {
  % nice rotating arrow
  \path (node cs:name=turnstile, angle=45) -- +(2mm,2mm) node [name=arr1] {};
  \draw [->,thick,color=red] (arr1)
	arc[radius=17mm, start angle=45, end angle=0]
	node [xshift=2ex, rotate=270] {tdO unlocks}
	arc[radius=17mm, start angle=0, end angle=-45];
}

\onslide<3-> {
  \node [name=allprio, ellipse, minimum width=10em, minimum height=4em,
	draw, thick, color=red] at (tdB.center){};
  \draw [->,thick,color=red] (allprio.north east) to [out=45, in=270]
	node [above, sloped, pos=.6] { priority } (owner);
}
\onslide<4-> {
  \node [name=lock2, below=2cm of tdB, draw, thick, rounded corners]
	{\Large{lock2}};
  \draw [->,thick] (lock2) -- node [above,sloped,pos=.4] {owner} (tdB);
  \node [name=turnstile2, left=1cm of lock2, signal, draw, thick,
	minimum height=2em, minimum width=7em] {};
  \node [above=of turnstile2] {lock2s' turnstile};
  \draw [<->,thick] (lock2) -- (turnstile2);
  \node [name=allprio2, ellipse, minimum width=8em, minimum height=3em,
	draw, thick, color=red] at (turnstile2.center){};
  \draw [->,thick,color=red] (allprio2.north east) to [out=15, in=225]
	node [above, sloped] { priority } (tdB);
}
\end{tikzpicture}
\end{figure}
\end{frame}


\begin{frame}
\frametitle{turnstiles implementation}
\begin{itemize}
  \item {Turnstiles are ephemeral, e.g. don't exist without contention}
  \item {Any lock might require a turnstile}
  \item {A turnstile can queue many threads}
  \item {A thread can hold many turnstiles}
  \item {A thread can stay only in one turnstile}
\end{itemize}
\onslide<2-> {
\begin{figure}
\begin{tikzpicture}[every node/.style={draw, node distance=10mm}]
  \node [name=turnstile, struct, rectangle split parts = 5] {
    \textbf{struct turnstile}
    \nodepart{two}	LIST\_HEAD ts\_blocked[2]
    \nodepart{three}	LIST\_HEAD ts\_pending
    \nodepart{four}	struct lock\_object *ts\_lockobj
    \nodepart{five}	struct thread *ts\_owner
  };
  \node [name=thread, right=of turnstile, struct, rectangle split parts = 6] {
    \textbf{struct thread}
    \nodepart{two}	\ldots
    \nodepart{three}	struct turnstile *td\_turnstile
    \nodepart{four}	struct turnstile *td\_blocked
    \nodepart{five}	LIST\_HEAD td\_contested
    \nodepart{six}	\ldots
  };
\end{tikzpicture}
\end{figure}
}
\end{frame}


\usebackgroundtemplate{
  \hbox to
  \paperheight{\hfil\includegraphics[height=\paperheight]{witness.png}}
} 
\FootReferences{}{}
\begin{frame}
\frametitle<1>{lock order reversal (LOR)}
\frametitle<2>{lock order reversal (LOR) and other locking problems}
\begin{center}
\begin{columns}
  \begin{column}{.4\paperwidth}
    {\Large CPU 1, thread A}
    \srcline {%
	  mtx\_lock(\&mtx\_A);\\
	  mtx\_lock(\&mtx\_B);
    }
  \end{column}
  \begin{column}{.4\paperwidth}
    {\Large CPU 2, thread B}
    \srcline {%
	  mtx\_lock(\&mtx\_B);\\
	  mtx\_lock(\&mtx\_A);
    }
  \end{column}
\end{columns}
\end{center}
\onslide<2> {
  Also:
  \begin{itemize}
    \item {Sleeping with lock held}
    \item {Obtaining blockable lock with spin lock held}
    \item {Returning from a syscall with lock held}
    \item {Recursing on non-recursive lock}
  \end{itemize}
}
\end{frame}


\usebackgroundtemplate{
  \hbox to
  \paperheight{\hfil\includegraphics[height=\paperheight]{witness2.png}}
} 
\FootReferences{witness(4)}{sys/kern/subr\_witness.c}
\begin{frame}
\frametitle{witness(4)}
\only<1,2> {
  \begin{itemize}
    \item {Maintains ordered list of locks for each process}
    \item {Maintains global list of well known locks in correct order
	   of acquisition}
    \item {Maintains dynamic tree of lock orders for every lock in system}
    \item {Compares threads' list against global list and dynamic tree}
    \item {Reports violations}
  \end{itemize}
}
\only<2> {
  \shellcmd{%
    \# kgdb\\
    (kgdb) p td->td\_sleeplocks\\
    (kgdb) p td->td\_sleeplocks->ll\_children[0].li\_lock\\
    (kgdb) p *td->td\_sleeplocks->ll\_children[0].li\_lock->lo\_witness\\
  }
}
\only<3> {
  Example warning:
  \shellcmd{\tiny{%
  lock order reversal:\\
   1st 0xfffff800014b3d50 ufs (ufs) \@ /usr/src/sys/kern/vfs\_subr.c:2101\\
   2nd 0xfffffe001ec98ab8 bufwait (bufwait) \@ /usr/src/sys/ufs/ffs/ffs\_vnops.c:262\\
   3rd 0xfffff80017c8dd50 ufs (ufs) \@ /usr/src/sys/kern/vfs\_subr.c:2101\\
  KDB: stack backtrace:\\
  db\_trace\_self\_wrapper() at db\_trace\_self\_wrapper+0x2b/frame 0xfffffe002cdb1dd0\\
  kdb\_backtrace() at kdb\_backtrace+0x39/frame 0xfffffe002cdb1e80\\
  witness\_checkorder() at witness\_checkorder+0xd23/frame 0xfffffe002cdb1f10\\
  \_\_lockmgr\_args() at \_\_lockmgr\_args+0x86c/frame 0xfffffe002cdb2040\\
  ffs\_lock() at ffs\_lock+0x84/frame 0xfffffe002cdb2090\\
  VOP\_LOCK1\_APV() at VOP\_LOCK1\_APV+0xf5/frame 0xfffffe002cdb20c0\\
  \_vn\_lock() at \_vn\_lock+0xab/frame 0xfffffe002cdb2130\\
  vget() at vget+0x70/frame 0xfffffe002cdb2180\\
  vfs\_hash\_get() at vfs\_hash\_get+0xf5/frame 0xfffffe002cdb21d0\\
  ffs\_vgetf() at ffs\_vgetf+0x41/frame 0xfffffe002cdb2260\\
  softdep\_sync\_buf() at softdep\_sync\_buf+0x8fa/frame 0xfffffe002cdb2310\\
  ffs\_syncvnode() at ffs\_syncvnode+0x258/frame 0xfffffe002cdb2390\\
  ffs\_truncate() at ffs\_truncate+0x5b5/frame 0xfffffe002cdb2570\\
  ufs\_direnter() at ufs\_direnter+0x812/frame 0xfffffe002cdb2630\\
  ufs\_makeinode() at ufs\_makeinode+0x4bf/frame 0xfffffe002cdb27f0\\
  VOP\_CREATE\_APV() at VOP\_CREATE\_APV+0xea/frame 0xfffffe002cdb2820\\
  vn\_open\_cred() at vn\_open\_cred+0x300/frame 0xfffffe002cdb2970\\
  kern\_openat() at kern\_openat+0x261/frame 0xfffffe002cdb2ae0\\
  amd64\_syscall() at amd64\_syscall+0x265/frame 0xfffffe002cdb2bf0\\
  Xfast\_syscall() at Xfast\_syscall+0xfb/frame 0xfffffe002cdb2bf0\\
  }}
}
\end{frame}


\usebackgroundtemplate{}
\FootReferences{}{}
\begin{frame}
\frametitle{Practice}
  \begin{itemize}
    \item \Man{queue}{3}
    \item \Man{malloc}{9}
    \item \Man{mutex}{9}
  \end{itemize}
  Checkout or update todays examples.
  \shellcmd{%
  \# svn co http://svn.freebsd.org/base/user/glebius/course\\
  \# cd course\\
  \# cd 04.*/code\\
  }
  or
  \shellcmd{%
  \# cd course\\
  \# svn update\\
  \# cd 04.*/code\\
  }
\end{frame}

\end{document}
