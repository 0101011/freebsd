\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{tikz}
\usepackage{adjustbox}
\usepackage{url}
\usepackage{array}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{ifthen}

\usetikzlibrary{positioning}
\usetikzlibrary{shapes}
\usetikzlibrary{decorations.pathmorphing}

\input{../course.tex}

\title{File descriptors, capabilities, descriptor multiplexing}

\begin{document}

\begin{frame}
\titlepage
\end{frame}


\FootReferences{open(2), socket(2), dup(2), dup2(2), dup3(2), fork(2)}{}
\begin{frame}
\frametitle{File descriptors properties}
\onslide<1-> {
  Allocation:
  \srcline {%
	int fd;\\

	fd = open(path, flags, ...);\\
	fd = socket(domain, type, protocol);\\
	pipe(fds[]);
  }
}
\onslide<2-> {
  Usage:
  \srcline {%
	read(fd, buf, size);\\
	write(fd, buf, size);
  }
}
\onslide<3-> {
  Explicit duplication:
  \srcline {newfd = dup(fd);}
}
\onslide<4-> {
  Implicit duplication:
  \srcline {fork();}
}
\end{frame}


\FootReferences{unix(4)}{tools/regression/sockets/unix\_passfd}
\begin{frame}
\frametitle{File descriptors properties (non-standard)}
Passing descriptors via local socket:
\srcline {%
        msghdr.msg\_control = message;\\
        msghdr.msg\_controllen = sizeof(message);\\
        cmsghdr = (struct cmsghdr *)message;\\
        cmsghdr->cmsg\_len = CMSG\_LEN(sizeof(int));\\
        cmsghdr->cmsg\_level = SOL\_SOCKET;\\
        cmsghdr->cmsg\_type = SCM\_RIGHTS;\\
        *(int *)CMSG\_DATA(cmsghdr) = fd;\\
        sendmsg(sockfd, \&msghdr, 0);
}
Receiving:
\srcline {%
	recvmsg(sockfd, \&msghdr, 0);\\
	cmsghdr = CMSG\_FIRSTHDR(\&msghdr);\\
	fd = *(int *)CMSG\_DATA(cmsghdr);\\
}
\end{frame}


\FootReferences{}{sys/sys/file.h, sys/sys/filedesc.h}
\begin{frame}
\frametitle{File descriptors inside kernel}
\begin{figure}
\begin{tikzpicture}
  \node [name=file, struct, rectangle split parts=4] {
	\textbf{struct file}
	\nodepart{two} short f\_type
	\nodepart{three} void *f\_data
	\nodepart{four} struct fileops *f\_ops
  };
\onslide <2-> {
  \node [name=process, left=.4\paperwidth of file, yshift=.3\paperheight,
	 draw, circle] {
	user process
  };
  \node [name=fd, anchor=north, node distance=3mm,
	 below right=of process.center, draw, circle, inner sep=1pt] { fd };
}
\only<3> {
  \draw [->, decorate, decoration={snake, amplitude=1mm, segment length=1cm}]
	(fd) -- node [above, sloped] {???} (file.one west);
}
\only <4> {
  \node [name=filedesc, struct, rectangle split parts=2,
	 left=of file.north west, anchor=north east] {
	\textbf{struct filedesc}
	\nodepart{two} struct file fd\_ofiles[{\color{red}fd}]
  };
}
\onslide <5-> {
  \node [name=filedesc, struct, rectangle split parts=2,
	 left=of file.north west, anchor=north east] {
	\textbf{struct filedesc}
	\nodepart{two} struct \emph{filedescent} fd\_ofiles[{\color{red}fd}]
  };
}
\onslide <4-> {
  \node [name=proc, struct, rectangle split parts=2,
	 right=of process] {
	\textbf{struct proc}
	\nodepart{two} struct filedesc *p\_fd
  };
  \draw [->, decorate, decoration=snake] (process) -- (proc.one west);
  \draw [pointer] (proc.two west)
	 -- node [name=x,pos=1] {} +(-5mm,0) -- (filedesc.north -| x);
  \draw [pointer] (filedesc.two east) to [out=0, in=180] (file.one west);
}
\end{tikzpicture}
\end{figure}
\end{frame}


\FootReferences{capsicum(4), cap\_enter(2)}{}
\begin{frame}
\frametitle{Capability mode (capsicum)}
\begin{itemize}
  \item {Opening new descriptors forbidden}
  \item {Opened descriptors may have limits enforced}
\end{itemize}
\end{frame}


\FootReferences{}{sys/sys/file.h, sys/sys/filedesc.h}
\begin{frame}
\frametitle{Filedescent structure}
Filedescent combines descriptor and capability limits on it
\begin{figure}
\begin{tikzpicture}
  \node [name=filedescent, struct, rectangle split parts=4] {
	\textbf{struct filedescent}
	\nodepart{two} struct file *fde\_file
	\nodepart{three} struct filecaps fde\_caps
	\nodepart{four} uint8\_t fde\_flags
  };
  \node [name=filecaps, right=of filedescent.north east, anchor=north west,
	 struct, rectangle split parts=5] {
	\textbf{struct filecaps}
	\nodepart{two} cap\_rights\_t fc\_rights
	\nodepart{three} u\_long *fc\_ioctls
	\nodepart{four} int16\_t fc\_nioctls
	\nodepart{five} uint32\_t fc\_fcntls
  };
  \draw (filedescent.two split east) -- (filecaps.north west);
  \draw (filedescent.three split east) -- (filecaps.south west);
\end{tikzpicture}
\end{figure}
\end{frame}


\FootReferences{select(2), poll(2)}{sys/kern/kern\_descrip.c}
\begin{frame}
\frametitle{Basic descriptor I/O multiplexing APIs}
\onslide<1-> {
  BSD API
  \srcline {%
	int select(int nfds, fd\_set *readfds, fd\_set *writefds,
	fd\_set *exceptfds,
        struct timeval *timeout);
  }
  \srcline {%
  \#define FD\_SETSIZE      1024U
  \#define NFDBITS        (sizeof(u\_long) * 8)\\
  typedef struct \{\\
	u\_long       fds\_bits[howmany(FD\_SETSIZE, NFDBITS)];\\
  \} fd\_set;\\
  }
}
\onslide<2-> {
  System V API
  \srcline {%
	int poll(struct pollfd fds[], nfds\_t nfds, int timeout);
  }
  \srcline {%
     struct pollfd \{\\
         int    fd;\\
         short  events;\\
         short  revents;\\
     \};
  }
}
\end{frame}


\FootReferences{select(2), poll(2)}{sys/kern/kern\_descrip.c}
\begin{frame}[fragile]
\frametitle{Basic descriptor I/O multiplexing implementation}
\lstset{language=C}
\begin{lstlisting}
/* Iterate until the timeout expires or
   descriptors become ready. */
for (;;) {
        error = selscan(td, ibits, obits, nd);
        if (error || td->td_retval[0] != 0)
                break;
        error = seltdwait(td, asbt, precision);
        if (error)
                break;
        error = selrescan(td, ibits, obits);
        if (error || td->td_retval[0] != 0)
                break;
}
\end{lstlisting}
\end{frame}


\FootReferences{}{}
\begin{frame}
\frametitle{c10k problem: bottlenecks of basic APIs}
\begin{itemize}
\onslide <1-> {
  \item {O(N) complexity}
}
\onslide <2-> {
  \item {Usually only small ratio of descriptors is available}
  \item {Data for all descriptors must be passed to/from kernel}
}
\onslide <3-> {
  \item {\textbf{select(2)}: FD\_SETSIZE is only 1024 bits}
}
\onslide <4-> {
  \item {\textbf{poll(2)}: sizeof(struct pollfd) == 8}
}
\end{itemize}
\end{frame}


\FootReferences{}{}
\begin{frame}
\frametitle{requirements to new API}
\begin{itemize}
\onslide <1-> {
  \item {Kernel knows application state}
}
\onslide <2-> {
  \item {Reports events instead of descriptor availability}
}
\onslide <3-> {
  \item {Multiple listeners}
}
\onslide <4-> {
  \item {``Level triggered'' or ``Event triggered''}
}
\end{itemize}
\end{frame}


\FootReferences{kevent(2)}{}
\begin{frame}
\frametitle{kevent(2) API}
  \srcline {%
	kqfd = kqueue();\\
	kevent(kqfd, changelist, n\_changes, eventlist, n\_events, timeout);\\
  }
\end{frame}


\FootReferences{kevent(2)}{}
\begin{frame}[fragile]
\frametitle{kevent(2) API}
\lstset{language=C}
\begin{lstlisting}
struct kevent {
   uintptr_t  ident;  // identifier of event
   short      filter; // filter for event
   u_short    flags;  // action flags
   u_int      fflags; // filter specific flags
   intptr_t   data;   // filter specific data
   void       *udata; // application specific data
};
\end{lstlisting}
\end{frame}


\FootReferences{}{sys/sys/event.h, sys/sys/eventvar.h, sys/kern/kern\_event.c}
\begin{frame}
\frametitle{Kernel view of kevent(2)}
\begin{figure}
\begin{tikzpicture}[thick]
  \tikzset {
	el/.style={draw, node distance=0, minimum width=3ex},
  }

  \node [name=kqA, draw ] { kq A };
  \node [name=ea1, el, below=of kqA] {};
  \node [name=ea2, el, below=of ea1] {};
  \node [name=ea3, el, below=of ea2] {};
  \node [name=ea4, el, below=of ea3] {};
  \node [name=ea5, el, below=of ea4] {};
  \node [name=ea6, el, below=of ea5] {};
  \node [name=aa1, el, right=of kqA.north east, anchor=north west] {};
  \node [name=aa2, el, below=of aa1] {};

  \node [name=kqB, draw, right=.6\paperwidth of kqA ] { kq B };
  \node [name=eb1, el, below=of kqB] {};
  \node [name=eb2, el, below=of eb1] {};
  \node [name=eb3, el, below=of eb2] {};
  \node [name=eb4, el, below=of eb3] {};
  \node [name=eb5, el, below=of eb4] {};
  \node [name=eb6, el, below=of eb5] {};
  \node [name=ab1, el, right=of kqB.north east, anchor=north west] {};
  \node [name=ab2, el, below=of ab1] {};

  \node [name=sockbuf1, draw, below=.4\paperheight of kqA] { socket buffer };
  \node [name=sockbuf2, draw, below=.5\paperheight of kqA] { socket buffer };

  \node [name=knote1s1, draw, right=of sockbuf1, xshift=1cm] { knote };
  \node [name=knote1s2, draw, right=of sockbuf2, xshift=1cm] { knote };
  \node [name=knote2s2, draw, right=of knote1s2] { knote };

  \draw [->] (sockbuf1) -- node [above] {knlist} (knote1s1);
  \draw [->] (sockbuf2) -- node [above] {knlist} (knote1s2);
  \draw [->] (knote1s2) -- (knote2s2);

  \node [name=vnode, draw, below right=.2\paperwidth of kqA] { vnode };
  \node [name=knotev, draw, right=of vnode] { knote };
  \draw [->] (vnode) -- (knotev);

  \draw [->, dotted] (ea2) -| (node cs:name=knotev, angle=110);
  \draw [->, dotted] (ea6) -| (knote1s1);
  \draw [->, dotted] (knote1s1) -- (knote1s2);
  \draw [->, dashed] (aa1) -| (node cs:name=knotev, angle=70);
  \draw [->, dashed] (aa2) -- +(+.5\paperwidth, 0) |- (knote1s1);

  \draw [->, dotted] (eb3) -- +(-.1\paperwidth, 0) |- (knote2s2);

\end{tikzpicture}
\end{figure}
\end{frame}


\end{document}
