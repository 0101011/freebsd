/* -*- Mode: C; indent-tabs-mode: t; c-basic-offset: 4; tab-width: 4 -*- */
/*
 * main.c - Auto-generated by Anjuta's Makefile project wizard
 * 
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <fcntl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <unistd.h>
#include <errno.h>

#include "bsdbus.h"

static char* known_bus_path[DBUS_ALL_KNOWN_BUS] = { NULL, NULL};

size_t
dbus_pad (size_t stream_index, size_t align)
{
		size_t pad = stream_index % align;
		return ((pad == 0) ? 0 : align - pad);
}

size_t
dbus_align_index(size_t stream_index, size_t align)
{
		size_t pad = stream_index % align;
		return (stream_index += (pad == 0) ? 0 : align - pad);
}

void
dbus_push_elem(struct DBus_message *message, enum DBus_param_type type, void *data, size_t size)
{
		struct DBus_body_elem *elem = (struct DBus_body_elem *)malloc(sizeof(struct DBus_body_elem));
	
		elem->type = type;
		elem->data = data;
		elem->size = size;
		elem->next = NULL;		
	
		if (message->start == NULL) {
				message->start = elem;
		} else {
				message->tail->next = elem;
		}
		
		message->tail = elem;
		
		// add padding size
	//	printf("size = %lu, align = %lu\n", message->size, DBus_field_align[type]);
		message->size += dbus_pad (message->size, DBus_field_align[type]);
		// add new body element size
	//	printf("pad + size = %lu\n", message->size);
		message->size += size;
		message->elem_count += 1;
}

void
dbus_push_byte(struct DBus_message *message, uint8_t val)
{
		uint8_t	*data = (uint8_t *)malloc(1);
		*data = val;
	
		dbus_push_elem(message, DBUS_PARAM_BYTE, data, 1);
}

void
dbus_push_boolean(struct DBus_message *message, uint32_t val)
{
		uint32_t	*data = (uint32_t *)malloc(4);
		*data = val;
	
		dbus_push_elem(message, DBUS_PARAM_BOOLEAN, data, 4);
}

void
dbus_push_int16(struct DBus_message *message, int16_t val)
{
		int16_t	*data = (int16_t *)malloc(2);
		*data = val;
	
		dbus_push_elem(message, DBUS_PARAM_INT16, data, 1);
}

void
dbus_push_uint16(struct DBus_message *message, uint16_t val)
{
		uint16_t	*data = (uint16_t *)malloc(2);
		*data = val;
	
		dbus_push_elem(message, DBUS_PARAM_UINT16, data, 2);
}

void
dbus_push_int32(struct DBus_message *message, int32_t val)
{
		int32_t	*data = (int32_t *)malloc(4);
		*data = val;
	
		dbus_push_elem(message, DBUS_PARAM_INT32, data, 4);
}

void
dbus_push_uint32(struct DBus_message *message, uint32_t val)
{
		uint32_t	*data = (uint32_t *)malloc(4);
		*data = val;
	
		dbus_push_elem(message, DBUS_PARAM_UINT32, data, 4);
}

void
dbus_push_int64(struct DBus_message *message, int64_t val)
{
		int64_t	*data = (int64_t *)malloc(8);
		*data = val;
	
		dbus_push_elem(message, DBUS_PARAM_INT64, data, 8);
}

void
dbus_push_uint64(struct DBus_message *message, uint64_t val)
{
		uint64_t	*data = (uint64_t *)malloc(8);
		*data = val;
	
		dbus_push_elem(message, DBUS_PARAM_UINT64, data, 8);
}

void
dbus_push_double(struct DBus_message *message, double val)
{
		double	*data = (double *)malloc(8);
		*data = val;
	
		dbus_push_elem(message, DBUS_PARAM_DOUBLE, data, 8);
}

void
dbus_push_struct_align(struct DBus_message *message)
{
		dbus_push_elem(message, DBUS_PARAM_STRUCT, NULL, 0);
}

void
dbus_push_string(struct DBus_message *message, const char *val)
{
		uint32_t	len = (uint32_t)strlen(val);
		uint8_t		*data = (uint8_t *)malloc(len + 5);
		
		*((uint32_t *)data) = len;
		//data += 4;
	
		memcpy(data + 4, val, len);
		data[len + 4] = '\0';
	
		dbus_push_elem(message, DBUS_PARAM_STRING, data, len + 5);
}

void
dbus_push_object_path(struct DBus_message *message, const char *val)
{
	/* TODO: valid object path check */
		dbus_push_string (message, val);
}

void
dbus_push_signature(struct DBus_message *message, const char *val)
{
		uint8_t	len = (uint8_t)strlen(val);
		uint8_t		*data = (uint8_t *)malloc(len + 2);
		
		*data = len;
		//data += 1;
	
		memcpy(data + 1, val, len);
		data[len + 1] = '\0';
	
		dbus_push_elem(message, DBUS_PARAM_SIGNATURE, data, len + 2);
}

struct DBus_message *
dbus_alloc_message()
{
		struct DBus_message *tmpMessage = malloc(sizeof(struct DBus_message));
			
		if (tmpMessage == NULL) {
				printf("failed to allocate memory for message.\n");
				return (NULL);
		}
	
		memset(tmpMessage, 0, sizeof(struct DBus_message));
	
		return (tmpMessage);
}

void
dbus_free_message(struct DBus_message *message)
{
		struct DBus_body_elem *elem = message->start;
	
		while (elem != NULL) {
				struct DBus_body_elem *tmp = elem->next;
				free(elem->data);
				free(elem);
				elem = tmp;
		}
	
		free(message);
}

void *
dbus_format_message(struct DBus_message *message, int pad)
{
	//	printf("dbus_format_message(%lu):\n", message->size);
	
		if (message->size == 0) {
				return (message);
		}
	
		if (pad != DBUS_NO_PADDING) {
				message->size += dbus_pad(message->size, pad);
		}
		// allocating storage for body
		message->data = malloc(message->size);
			
		if (message->data == NULL)
				return (NULL);

		memset(message->data, 0, message->size);
	
		size_t  pos = 0;
		uint8_t *data = (uint8_t *)message->data;
	
		struct DBus_body_elem *elem = message->start;
	
		while (elem != NULL) {
		
				pos += dbus_pad (pos, DBus_field_align[elem->type]);
				
				if (elem->data != NULL) /* may be NULL only for structure */
						memcpy(data + pos, elem->data, elem->size);
			
				pos += elem->size;
			
				elem = elem->next;
		}
	
		return (message->data);
}

enum DBus_communication_state
dbus_send(struct DBus_connection *connection, struct DBus_message *message,
	const char *path, const char *interface, const char *name)
{
		struct DBus_message					*hdrMsg = dbus_alloc_message ();
		struct DBus_message_header  hdr;

		printf("dbus_send(): ");
		hdr.endyFlag = DBUS_LITTLE_ENDIAN;
		hdr.type = DBUS_METHOD_CALL;
		hdr.flags = 0;
		hdr.proto = 1;
		hdr.length = message->size;
		hdr.serial = 1;

		
		dbus_push_struct_align(hdrMsg);
		dbus_push_byte(hdrMsg, DBUS_PATH);
		dbus_push_signature(hdrMsg, "o");
		dbus_push_object_path(hdrMsg, path);

		dbus_push_struct_align(hdrMsg);
		dbus_push_byte(hdrMsg, DBUS_INTERFACE);
		dbus_push_signature(hdrMsg, "s");
		dbus_push_string(hdrMsg, interface);

		dbus_push_struct_align(hdrMsg);
		dbus_push_byte(hdrMsg, DBUS_MEMBER);
		dbus_push_signature(hdrMsg, "s");
		dbus_push_string(hdrMsg, name);

		dbus_push_struct_align(hdrMsg);
		dbus_push_byte(hdrMsg, DBUS_DESTINATION);
		dbus_push_signature(hdrMsg, "s");
		dbus_push_string(hdrMsg, DBUS_SERVICE_DBUS);

		hdr.arrSize = hdrMsg->size;
		
		dbus_format_message (hdrMsg, 8);
	
		FILE *fd = connection->fd;
		
		if (1 != fwrite(&hdr, sizeof(struct DBus_message_header), 1, fd)) {
				printf("failed to write message header\n");
				goto error;
		}

		printf("data = %p, %lu", hdrMsg->data, hdrMsg->size);
		if (1 != fwrite(hdrMsg->data, hdrMsg->size, 1, fd)) {
				printf("failed to write message header fields\n");
				goto error;
		}
		
		printf("; data = %p, %lu: ", message->data, message->size);
		if (message->size != 0) {
				if (1 != fwrite(message->data, message->size, 1, fd)) {
						printf("failed to write message body\n");
						goto error;
				}
		}

		fflush(fd);
	
		printf("ok\n");
	
		uint8_t reply[512];
		ssize_t reply_size = 0;
	
		usleep(10);
		reply_size = recv(connection->socket, reply, 512, 0);
	
		FILE *fout = fopen("bsdbus.dump", "w+");
		fwrite(&hdr, sizeof(struct DBus_message_header), 1, fout);
		fwrite(hdrMsg->data, hdrMsg->size, 1, fout);
		fwrite(message->data, message->size, 1, fout);
	
		if (reply_size > 0) {
				printf("method return received\n");
				fwrite(reply, reply_size, 1, fout);
		}
	
		fflush(fout);
		fclose(fout);
	
		
	//	dbus_free_message(hdrMsg);
	
		return (DBUS_COMMUNICATION_OK);
	
error:
	//	dbus_free_message(hdrMsg);
		
		return (DBUS_COMMUNICATION_FAILED);
}

void
dbus_getuid(char *hex)
{
		uid_t uid = getuid();
	
		char str[128] = {0};
	
		sprintf(str, "%Lu", uid);
	
		size_t len = strlen(str);
	
		size_t i = 0;
	
		for (; i < len; ++i) {
				sprintf(&hex[2*i], "%2x", str[i]);
		}
		
		hex[2 * len] = '\0';
}

struct DBus_connection *
dbus_auth(struct DBus_connection* connection)
{
		FILE	*fd = connection->fd;
		char buf[256];
		char uid[256];
	
		dbus_getuid(uid);
	
		sprintf(buf, "AUTH EXTERNAL %s\r\n", uid);
	
		size_t res = fwrite(buf, strlen(buf), 1, fd);
		fflush(fd);
		
		if (1 != res) {
				printf("failed to write AUTH (%d)\n", ferror(fd));
				return (NULL);
		}

		printf("wrote string: %s", buf);
	
		buf[0] ='\0';
	
		while(buf[0] == '\0') {
				if ( (fgets(buf, 256, fd) == NULL) && (!feof(fd))) {
						printf("failed to get answer to AUTH (%d)\n", ferror(fd));
						if (ferror(fd) == EBADF)
								printf("stream is not readable\n");
						return (NULL);
				}
			
				usleep(10);
		}
	
		printf("received %s\n", buf);
	
		sprintf(buf, "BEGIN\r\n");
		fwrite(buf, strlen(buf), 1, fd);
		fflush(fd);
	
		return (connection);
}

struct dbus_credential_msg {
		struct cmsghdr  hdr;
		struct cmsgcred cred;
};

struct DBus_connection *
dbus_credential(struct DBus_connection* connection)
{
		int				written = -1;
		uint8_t byte = 0;

		struct iovec vec;
		struct msghdr msg;
		struct dbus_credential_msg cmsg;
	
		vec.iov_base = &byte;
		vec.iov_len = 1;

		memset (&msg, 0, sizeof (msg));
		msg.msg_iov = &vec;
		msg.msg_iovlen = 1;

		msg.msg_control = &cmsg;
		msg.msg_controllen = sizeof (cmsg);
  
		memset (&cmsg, 0, sizeof (cmsg));

		cmsg.hdr.cmsg_len = sizeof (cmsg);
		cmsg.hdr.cmsg_level = SOL_SOCKET;
		cmsg.hdr.cmsg_type = SCM_CREDS;

		do {
				written = sendmsg (connection->socket, &msg, 0);
		} while (written < 0 && errno == EINTR);
			
		if (written != 1) {
      printf("failed to write credentials byte. %s\n", written == 0 ?
				 "no bytes written" : "error occured");
      return (NULL);
		}
	
		printf ("wrote credentials byte\n");

		return (connection);
}

struct DBus_connection *
dbus_connect(enum DBus_connection_type conType)
{
		if (conType >= DBUS_ALL_KNOWN_BUS) {
				return (NULL);
		}
	
		if (known_bus_path[conType] == NULL) {
				const char *path = getenv(DBus_connection_str[conType]);
			
				if (path == NULL) {
						known_bus_path[conType] = strdup(DBus_default_path[conType]);
				} else {
			
						const char *eq = strchr(path, '=');
			
						if (eq == NULL)
								return (NULL);
			
						const char *zap = strchr(path, ',');
			
						size_t len = (zap != NULL) ? (zap - eq - 1) : strlen(path) - (eq - path) - 1;
			
						known_bus_path[conType] = (char *)malloc(len);
						memcpy(known_bus_path[conType] , eq + 1, len);
						known_bus_path[conType][len] = '\0';
				}
		}
	
		struct DBus_connection *tmpStruct =
					(struct DBus_connection *)malloc(sizeof(struct DBus_connection));
	
		memset(tmpStruct, 0, sizeof(struct DBus_connection));
	
		if (!dbus_open_connect (tmpStruct, known_bus_path[conType])) {
				free(tmpStruct);
				return (NULL);
		}

		if (!dbus_credential(tmpStruct)) {
				dbus_disconnect(tmpStruct);
				return (NULL);
		}
			
		if (!dbus_auth(tmpStruct)) {
				dbus_disconnect (tmpStruct);
				return (NULL);
		}
	
		printf("connected to dbus\n");

		return (tmpStruct);
}

void
dbus_disconnect(struct DBus_connection *connection)
{
		if (connection->socket != -1) {
				if (connection->fd != NULL)
						fclose(connection->fd);
				else
						close(connection->socket);
		}
	
		printf("disconnected...\n");
	
		free(connection);
}

struct DBus_connection *
dbus_open_connect(struct DBus_connection *connection, const char *path)
{
		struct sockaddr_un	addr;
		size_t						len;
	
		connection->socket = socket(AF_LOCAL, SOCK_STREAM, 0);
		
		if (connection->socket < 0) {
				printf("Failed to open socket\n");
				return (NULL);
		}
	
		memset(&addr, 0, sizeof(addr));
	
		addr.sun_family = PF_LOCAL;
		len = strlen (path);
		
		memcpy (addr.sun_path, path, len);
		
		printf("connecting to %s\n", path);	
	
		int result = connect(connection->socket, (struct sockaddr *)&addr, 
							 sizeof(struct sockaddr_un));

		if (result < 0)   {  
				printf("Failed to connect to socket %s\n", path);

				close(connection->socket);
				connection->socket = -1;
			 
				return (NULL);
		}

		int flags = fcntl (connection->socket, F_GETFL, 0);
  
		if (flags < 0)   {
				printf("Failed to get socket flags\n");
				
				close(connection->socket);
				connection->socket = -1;
			 
				return (NULL);
		}

	/*	result = fcntl (connection->socket, F_SETFL, flags | O_NONBLOCK);
	
		if (result < 0)  {
  				printf("Failed to set O_NONBLOCK flag on connection socket\n");
				
				close(connection->socket);
				connection->socket = -1;
			 
				return (NULL);    
		}
*/


	connection->fd = fdopen(connection->socket, "r+");

		if (connection->fd == NULL) {
				printf("Failed to open FILE descriptor\n");
				close(connection->socket);
				connection->socket = -1;
				return (NULL);
		}

		return (connection);
}

int main()
{
	printf("bsdbus test\n");
	
	struct DBus_connection *connection = dbus_connect (DBUS_SESSION_BUS);
	
	if (connection == NULL) {
			printf("Failed to open connection to sesion bus\n");
			return (1);
	}
	
	struct DBus_message			*msg = dbus_alloc_message();
	
	if (dbus_format_message (msg, DBUS_NO_PADDING) == NULL) {
			printf("failed to format message\n");
	} else {
			dbus_send(connection, msg, DBUS_PATH_DBUS, DBUS_INTERFACE_DBUS,
					  "Hello");
	}
	
	// dbus_free_message(msg);

	dbus_disconnect (connection);
	
	return (0);
}
