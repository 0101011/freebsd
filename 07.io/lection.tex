\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{tikz}
\usepackage{adjustbox}
\usepackage{url}
\usepackage{array}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{ifthen}

\usetikzlibrary{positioning}
\usetikzlibrary{shapes}
\usetikzlibrary{decorations.pathmorphing}

\input{../course.tex}

\title{Input/Output system: files and VFS}

\begin{document}

\begin{frame}
\titlepage
\end{frame}


\begin{frame}
\frametitle{read(2), readv(2), write(2), writev(2)}
\note {
	- Run the strategy.d and display typical I/O backtrace,
	  then continue with slides. The trace will lead us through
	  the entire lection.
}
\begin{itemize}
\onslide <1-> {
  \item {Syscall handler fills in \emph{struct uio}.}
}
\onslide <2-> {
  \item {Generic descriptor read/write handler 
	 resolves file descriptor to \emph{struct file}.}
  \item {Method from \emph{struct file} is called: fo\_read or fo\_write.}
}
\onslide <3-> {
  \item {Vnode method passes \emph{uio} into VFS(9)}
}
\onslide <4-> {
  \item {Eventually \emph{struct bio} reaches GEOM(4) \ldots}
  \item {\ldots and a disk driver}
}
\end{itemize}
\end{frame}


\FootReferences{uiomove(9)}{sys/sys/uio.h}
\begin{frame}[fragile]
\frametitle{The user input/output structure}
\begin{verbatim}
struct uio {
  struct  iovec *uio_iov;    /* scatter/gather list */
  int     uio_iovcnt;        /* length of scatter/gather list */
  off_t   uio_offset;        /* offset in target object */
  ssize_t uio_resid;         /* remaining bytes to copy */
  enum    uio_seg uio_segflg;/* address space */
  enum    uio_rw uio_rw;     /* operation */
  struct  thread *uio_td;    /* owner */
};
\end{verbatim}
\end{frame}


\FootReferences{}{sys/kern/sys\_generic.c, sys/kern/kern\_descrip.c}
\begin{frame}
\only<1> {
  \frametitle{Resolving descriptor to \emph{struct file}}
}
\only<2> {
  \frametitle{Resolving descriptor to \emph{struct file}\\
	      \ldots and \emph{fo\_write} calling method on it}
}
\onslide<1-> {
  sys/sys\_generic.c:kern\_writev():
  \srcline {%
	fget\_write(td, fd, cap\_rights\_init(\&rights, CAP\_WRITE), \&file);
  }
}
\onslide<2-> {
  sys/sys\_generic.c:dofilewrite():
  \srcline {%
	fo\_write(fp, auio, td->td\_ucred, flags, td);
  }
}
\end{frame}


\FootReferences{}{sys/sys/file.h}
\begin{frame}[fragile]
\frametitle{File methods}
\small\begin{verbatim}
typedef int fo_rdwr_t(struct file *fp, struct uio *uio,
  struct ucred *active_cred, int flags,
  struct thread *td);
...
struct fileops {
  fo_rdwr_t       *fo_read;
  fo_rdwr_t       *fo_write;
  fo_truncate_t   *fo_truncate;
  fo_ioctl_t      *fo_ioctl;
  fo_poll_t       *fo_poll;
  fo_kqfilter_t   *fo_kqfilter;
  fo_stat_t       *fo_stat;
  fo_close_t      *fo_close;
  fo_chmod_t      *fo_chmod;
  fo_chown_t      *fo_chown;
  fo_sendfile_t   *fo_sendfile;
  fo_seek_t       *fo_seek;
};
\end{verbatim}
\end{frame}


\FootReferences{}{sys/sys/file.h}
\begin{frame}[fragile]
\frametitle{Calling file operations (methods)}
\small\begin{verbatim}
static inline int
fo_write(struct file *fp, struct uio *uio,
  struct ucred *cred, int flags, struct thread *td)
{

    return ((*fp->f_ops->fo_write)(fp, uio, cred,
      flags, td));
}
\end{verbatim}
\onslide <2-> {
\begin{itemize}
  \item{Any \emph{struct file} has a valid f\_ops pointer.}
  \item{Dead file's f\_ops point at \&badfileops.}
\end{itemize}
}
\end{frame}


\FootReferences{vnode(9)}{sys/kern/vfs\_vnops.c}
\begin{frame}[fragile]
\frametitle{a vnode(9) backed file}
\srcline{%
  fp->f\_type == DTYPE\_VNODE\\
  fp->f\_ops == \&vnops\\
  fp->f\_vnode != NULL
}
\small\begin{verbatim}
struct vnode {
  ...
  enum    vtype v_type;         /* vnode type */
  struct  vop_vector *v_op;     /* vnode operations vector */
  void    *v_data;              /* private data for fs */
  struct  mount *v_mount;       /* ptr to vfs we are in */
  int     v_usecount;           /* ref count of users */
  int     v_holdcnt;            /* prevents recycling. */
  struct bufobj   v_bufobj;     /* Buffer cache object */
  ...
}
\end{verbatim}}
\end{frame}


\FootReferences{vnode(9), VFS(9)}
	{sys/kern/vfs\_default.c, ufs/ffs/ffs\_vnops.c, ufs/ufs/ufs\_vnops.c}
\begin{frame}
\frametitle{VFS(9) - object oriented approach to vnodes}
\only <1> {
  VOP\_READ() resolves to the first vop, that supports read.
}
\only <2> {
  VFS(9) example: ffs/ufs vops.
}
\begin{figure}
\small\begin{tikzpicture}
\only <1> {
  \node [name=vop1, struct, rectangle split parts=6] {
	\textbf{struct vop\_vector}
	\nodepart{two}struct vop\_vector *vop\_default 
	\nodepart{three}vop\_read\_t vop\_read
	\nodepart{four}vop\_write\_t vop\_write
	\nodepart{five}\ldots
	\nodepart{six}\textit{up to 70 ops}
  };
  \node [name=vop2, struct, right=of vop1.north east, anchor=north west,
	 rectangle split parts=4] {
	\textbf{struct vop\_vector}
	\nodepart{two}struct vop\_vector *vop\_default 
	\nodepart{three}vop\_strategy\_t vop\_strategy
	\nodepart{four}\ldots
  };
  \node [name=vop3, struct, below=of vop2, rectangle split parts=1] {
	\textbf{struct vop\_vector}
  };
  \draw [pointer] (vop1.two east) to [out=0, in=180] (vop2.one west);
  \draw [pointer] (vop2.two east) -- +(5mm, 0) |- (vop3);
}
\only <2> {
  \node [name=vop1, struct, rectangle split parts=5] {
	\textbf{ffs\_vnodeops}
	\nodepart{two}vop\_default 
	\nodepart{three}vop\_read = ffs\_read
	\nodepart{four}vop\_write = ffs\_write
	\nodepart{five}\ldots
  };
  \node [name=vop2, struct, right=of vop1.north east, anchor=north west,
	 rectangle split parts=4] {
	\textbf{ufs\_vnodeops}
	\nodepart{two}vop\_default 
	\nodepart{three}vop\_strategy = ufs\_strategy
	\nodepart{four}\ldots
  };
  \node [name=vop3, struct, below=of vop2, rectangle split parts=1] {
	\textbf{default\_vnodeops}
  };
  \draw [pointer] (vop1.two east) to [out=0, in=180] (vop2.one west);
  \draw [pointer] (vop2.two east) -- +(5mm, 0) |- (vop3);
}
\end{tikzpicture}
\end{figure}
\end{frame}


\FootReferences{vnode(9), VFS(9)}{sys/tools/vnode\_if.awk,
		sys/kern/vnode\_if.src}
\begin{frame}[fragile]
\frametitle{VFS(9) - object oriented approach to vnodes}
Code is generated from vnode\_if.src file by vnode\_if.awk script.
\begin{verbatim}
%% read   vp  L L L
vop_read {
  IN struct vnode *vp;
  INOUT struct uio *uio;
  IN int ioflag;
  IN struct ucred *cred;
};
\end{verbatim}
\end{frame}

\FootReferences{vnode(9), VFS(9)}{sys/tools/vnode\_if.awk,
		sys/kern/vnode\_if.src}
\begin{frame}
\frametitle{VFS(9) - object oriented approach to vnodes}
\onslide <1-> {
Generated in vnode\_if.h:
\begin{itemize}
  \item{struct vop\_read\_args}
  \item{VOP\_READ\_APV() declaration}
  \item{VOP\_READ() inlined function}
\end{itemize}
}
\onslide <2-> {
Generated in vnode\_if.c:
\begin{itemize}
  \item{VOP\_READ\_APV() function}
\end{itemize}
}
\onslide <3> {
VOP\_READ\_APV():
\begin{itemize}
  \item{Does locking assertions}
  \item\textbf{Cycles through vop->vop\_default until vop\_read is defined}
  \item{Does tracing: ktr(9) and sdt(9)}
  \item{Runs VFS\_PROLOGUE(vp->v\_mount)}
  \item\textbf{Runs vop->vop\_read}
  \item{Runs VFS\_EPILOGUE(vp->v\_mount)}
  \item{Does locking assertions}
  \item{Does tracing: ktr(9) and sdt(9)}
\end{itemize}
}
\end{frame}


\FootReferences{buf(9)}{sys/sys/buf.h, sys/kern/vfs\_bio.c}
\begin{frame}[fragile]
\frametitle{buffer I/O}
\begin{verbatim}
struct buf {
  long    b_bufsize;    /* Allocated buffer size. */
  caddr_t b_data;       /* Base pointer. */
  off_t   b_offset;     /* Offset in the file. */
  long    b_resid;      /* Remaining bytes for i/o. */
  int     b_dirtyoff;   /* Offset in buffer of dirty region. */
  int     b_dirtyend;   /* Offset of end of dirty region. */
  ...
  daddr_t b_blkno;      /* Underlying physical block number. */
  daddr_t b_lblkno;     /* Logical block number. */
  ...
  struct vm_page *b_pages[btoc(MAXPHYS)];
  int     b_npages;
  ...
  struct bufobj   *b_bufobj;
}
\end{verbatim}
\end{frame}


\FootReferences{buf(9)}{sys/sys/bufobj.h, sys/kern/vfs\_bio.c}
\begin{frame}[fragile]
\frametitle{buffer I/O}
\begin{verbatim}
struct bufobj {
  struct vm_object *bo_object;  /* Place to store VM object */  
  struct buf_ops  *bo_ops;      /* Buffer operations */
  struct bufv     bo_clean;     /* Clean buffers */
  struct bufv     bo_dirty;     /* Dirty buffers */
  ...
};
 
TAILQ_HEAD(buflists, buf);
struct bufv {
  struct buflists bv_hd;        /* Sorted blocklist */
  struct pctrie   bv_root;      /* Buf trie */
  int             bv_cnt;       /* Number of buffers */
};
\end{verbatim}
\end{frame}

\end{document}
